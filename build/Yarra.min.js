"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Y=exports.Yarra=void 0;class Yarra extends Array{constructor(...args){return 1===args.length?args[0]instanceof Array?1===args[0].length?(super(1),this[0]=args[0][0]):super(...args[0]):"number"==typeof args[0]?(super(1),this[0]=args[0]):super(...args[0]):super(...args),new Proxy(this,{get:(target,name)=>{if("symbol"==typeof name)return target[name];if(void 0!==target[name])return target[name];if(!isNaN(+name)){var indices=+name;if(Number.isInteger(indices)&&indices<0)return target[target.length+indices]}indices=Yarra.toIndices(name,this.dimensions);return indices?target.getFrom(indices):target[name]},set:(target,name,value)=>{if("symbol"==typeof name)return target[name]=value,!0;if(!isNaN(+name)){var indices=+name;if(Number.isInteger(indices))return 0<=indices?target[indices]=value:target[target.length+indices]=value,!0}indices=Yarra.toIndices(name,this.dimensions);return indices?Array.isArray(value)?target.setFrom(indices,value):target.setAllFrom(indices,value):target[name]=value,!0}})}static toIndices(input,shape){const acceptable="0123456789 :#>,;";if(0!==input.trim().length&&[...input.trim()].every(c=>acceptable.includes(c))){const spacingOperators={":":(start,end,step)=>Yarra.range({start:start,end:end,step:step}),"#":(start,end,step)=>Yarra.range({start:start,end:end,step:step,inclusive:!0}),">":(start,n,step)=>Yarra.range({start:start,end:start+n,step:step})};for(var x of":#>,;")input=input.split(x).map(x=>x.trim()).join(x);var dimension,i,dimensions=new Yarra(input.split(";"));let dimensionsIndices=Yarra.allocate(dimensions.length);for([dimension,i]of dimensions.full){let dimensionIndices=[];for(var part of dimension.split(/[ ,]/))if(isNaN(+part)){for(var op in spacingOperators)if(part.includes(op)){var inputs=part.split(op).filter(Boolean).map(x=>+x),[a,b,c]=inputs;if(0===inputs.length){if(":"!==op)return;dimensionIndices.push(...spacingOperators[op](0,shape[i]))}else if(1===inputs.length)if(part.startsWith(op))dimensionIndices.push(...spacingOperators[op](0,a));else{if(":"!==op)return;dimensionIndices.push(...spacingOperators[op](a,shape[i]))}else if(2===inputs.length)dimensionIndices.push(...spacingOperators[op](a,b));else{if(3!==inputs.length)return;dimensionIndices.push(...spacingOperators[op](a,c,b))}}}else dimensionIndices.push(+part);dimensionsIndices[i]=dimensionIndices}return Yarra.generateTemplate(dimensionsIndices)}}static generateTemplate(input){if(0===input.length)return new Yarra;let output=Yarra.allocate(input.map(x=>x.length)),loopN=1;input.forEach(x=>loopN*=x.length);let offsets=Yarra.allocate(input.length).fill(0);for(let i=0;i<loopN;i++){output.set(offsets)(offsets.map((x,j)=>[...input[j]][x]));for(let j=offsets.length-1;0<=j&&(offsets[j]++,!(offsets[j]<input[j].length));j--)offsets[j]=0}return output}static allocate(...n){n[0]instanceof Array&&(n=n[0]);let out=new Yarra;out.length=n[0];let loopN=n[0];for(let i=1;i<n.length;i++){let index=Yarra.allocate(i);index.fill(0);for(let j=0;j<loopN;j++){out.set(index)(Yarra.allocate(n[i]));for(let k=i-1;0<=k&&(index[k]++,!(index[k]<n[k]));k--)index[k]=0}loopN*=n[i]}return out}static entries(x){return new Yarra(Object.entries(x))}static range({start:start=0,end:steps,step:step=1,inclusive:inclusive=!1}){var steps=(steps-start)/step,n=Math.ceil(steps)+(inclusive&&Number.isInteger(steps)?1:0);if(n<=0)return new Yarra;let arr=new Yarra(n);for(let i=0;i<n;i++)arr[i]=start+i*step;return arr}static rangeMap({start:start=0,end:steps,step:step=1,inclusive:inclusive=!1,f:f=x=>x}){var steps=(steps-start)/step,n=Math.ceil(steps)+(inclusive&&Number.isInteger(steps)?1:0);if(n<=0)return new Yarra;let arr=new Yarra(n);for(let i=0;i<n;i++)arr[i]=f(start+i*step);return arr}static linSpace(start=0,end=1,n=2){if(!Number.isInteger(n))throw Error("n not an integer");if(n<=1)throw Error("n must be greater than 1");return this.range({start:start,end:end,inclusive:!0,step:(end-start)/(n-1)})}static linSpaceMap(start=0,end=1,n=2,f){if(!Number.isInteger(n))throw Error("n not an integer");if(n<=0)throw Error("n must be positive");return this.rangeMap({start:start,end:end,inclusive:!0,step:(end-start)/(n-1),f:f})}get head(){return this[0]}get last(){return this[this.length-1]}get full(){return new Yarra([...this.entries()].map(([i,x])=>[x,i]))}get size(){let size=0;for(var x of this)void 0!==x&&size++;return size}get dimensions(){if(this[0]instanceof Array){var subDim=new Yarra(this[0]).dimensions;return subDim?new Yarra([this.length,...subDim]):new Yarra([this.length])}return new Yarra([this.length])}written(oxfordComma=!0){return 0===this.length?"":1===this.length?this[0]:2===this.length?this[0]+" and "+this[1]:this.initial().join(", ")+(oxfordComma?",":"")+" and "+this.last}initial(n=1){return this.slice(0,-n)}tail(n=1){return this.slice(n)}compact(){return this.filter(Boolean)}unique(loose=!1){return loose?this.filter((x,i,a)=>i===a.findIndex(y=>x==y)):new Yarra(new Set(this))}uniqueWith(f){return this.filter((x,i,a)=>i===a.findIndex(y=>f(x,y)))}isUnique(loose=!1){return this.length===this.unique(loose).length}isUniqueWith(f){return this.length===this.uniqueWith(f).length}count(f=Boolean){return this.reduce((s,x)=>s+(f(x)?1:0),0)}occurrences(f=a=>a){let output={};for(var x of this.map(f))output[x]?output[x]++:output[x]=1;return output}sample(){return this[Math.floor(Math.random()*this.length)]}chunk(n){return this.reduce((p,x,i)=>i%n?[...p.slice(0,-1),[...p.slice(-1)[0],x]]:[...p,[x]],[])}uncover(n=1){return this.flat(n)}cover(n=1){return n<1?this.clone():this.map(x=>new Yarra([x])).cover(n-1)}elementWise(arr,f,singleDimension=!1){if(singleDimension){if(this.length!==arr.length)throw Error("Unequal lengths");let output=Yarra.allocate(this.length);for(var i in this)"number"==typeof i&&(output[i]=f(this[i],arr[i],i));return output}if(!this.dimensions.equals(arr.dimensions))throw Error("Unequal dimensions");let output=Yarra.allocate(this.length);if(1===this.dimensions.length){for(let i in this)"number"==typeof i&&(output[i]=f(this[i],arr[i],i));return output}for(let i in this)output[i]=new Yarra(this[i]).elementWise(new Yarra(arr[i]),f);return output}add(arr){return this.elementWise(arr,(a,b)=>a+b)}mult(arr){return this.elementWise(arr,(a,b)=>a*b)}matrixMult(arr){if(2<this.dimensions.length||2<arr.dimensions.length||this.dimensions[1]!==arr.dimensions[0])throw Error("Dimensions don't work");let lhs=this,rhs=arr;1===this.dimensions.length&&(lhs=new Yarra(this)),1===arr.dimensions.length&&(rhs=new Yarra(arr));let output=Yarra.allocate(lhs.dimensions[0]);var rhst=rhs.transpose();for(let i=0;i<lhs.dimensions[0];i++){output[i]=Yarra.allocate(rhs.dimensions[1]);for(let j=0;j<rhs.dimensions[1];j++)output[i][j]=lhs[i].mult(rhst[j]).sum()}return output}transpose(){if(2<this.dimensions.length)throw Error("Unable to transpose over 2D");if(1===this.dimensions.length)return this.cover();let output=Yarra.allocate(this.dimensions[1]);for(var j in this[0])if("number"==typeof j)for(var i in output[j]=Yarra.allocate(this.dimensions[0]),this)output[j][i]=this[i][j];return output}transposeMutate(){return this.mutate(this.transpose())}sum(){return this.reduce((s,x)=>s+x)}product(){return this.reduce((s,x)=>s*x,1)}max(){return Math.max(...this)}min(){return Math.min(...this)}average(){return this.sum()/this.length}none(f){return!this.some(f)}mutate(newValue){this.length=newValue.length;for(var[x,i]of newValue.full)this[i]=x;return newValue}get(...indices){let output=this;for(var i of indices)output=output[i];return output}set(...indices){return indices[0]instanceof Array&&(indices=indices[0]),x=>{let output=this;for(var i of indices.slice(0,-1))output=output[i];return output[indices[indices.length-1]]=x,this}}getFrom(template){if((template=new Yarra(template))instanceof Yarra){let output=new Yarra,curr=this.clone();for(var[x,i]of template.full){if(!(x instanceof Array))throw Error("Invalid template");x[0]instanceof Array?output[i]=curr.getFrom(x):output[i]=curr.get(...x)}return output}}setAllFrom(template,value){var x;for(x of template=new Yarra(template)){if(!(x instanceof Array))throw Error("Invalid template");x[0]instanceof Array?this.setAllFrom(x,value):this.set(...x)(value)}return this}setFrom(template,values){const setFromRunner=(arr,template,values,location)=>{template=new Yarra(template),values=new Yarra(values);let curr=arr;for(var[x,i]of template.full){if(!(x instanceof Array))throw Error("Invalid template");x[0]instanceof Array?setFromRunner(curr,x,values,[...location,i]):curr.set(...x)(values.get(...location,i))}return this};return setFromRunner(this,template,values,[])}at(...indices){return indices[0]instanceof Array&&(indices=indices[0]),this.filter((_,i)=>indices.includes(i))}pullAt(...indices){if(0===indices.length)return this.clone();indices[0]instanceof Array&&(indices=indices[0]);var[accepted,rejected]=this.split((_,i)=>indices.includes(i));return this.mutate(rejected),accepted}mapMutate(f,thisArg){return this.mutate(this.map(f,thisArg))}filterMutate(f,thisArg){return this.mutate(this.filter(f,thisArg))}rejectMutate(f,thisArg){return this.mutate(this.reject(f,thisArg))}reject(f,thisArg){return this.filter((...args)=>!f(...args),thisArg)}rejectFull(f,thisArg){return this.full.filter(([x,i])=>!f(x,i,this),thisArg)}filterFull(f,thisArg){return this.full.filter(([x,i])=>f(x,i,this),thisArg)}split(f){let accepted=new Yarra,rejected=new Yarra;return this.forEach((x,i,arr)=>{(f(x,i,arr)?accepted:rejected).push(x)}),new Yarra(accepted,rejected)}splitFull(f){let accepted=new Yarra,rejected=new Yarra;return this.forEach((x,i,arr)=>{(f(x,i,arr)?accepted:rejected).push([x,i])}),new Yarra(accepted,rejected)}splitAt(...indices){return 0===indices.length?this.clone():1===(indices=indices[0]instanceof Array?indices[0]:indices).length?new Yarra(this.slice(0,indices[0]),this.slice(indices[0])):new Yarra([this.slice(0,indices[0]),...this.splitAt(indices.slice(1))])}findFull(f){for(let i=0;i<this.length;i++)if(f(this[i]))return[this[i],i]}findLast(f){for(let i=this.length-1;0<=i;i--)if(f(this[i]))return this[i]}findLastIndex(f){for(let i=this.length-1;0<=i;i--)if(f(this[i]))return i}findLastFull(f){for(let i=this.length-1;0<=i;i--)if(f(this[i]))return[this[i],i]}findAllIndex(f){return this.filterFull(f).map(([,i])=>i)}allIndexOf(v,loose=!1){return(loose?this.filterFull(x=>x==v):this.filterFull(x=>x===v)).map(([,i])=>i)}flattenDeep(){return this.flat(1/0)}shuffle(){let output=this.clone();for(let i=output.length-1;0<i;i--){var j=Math.floor(Math.random()*(i+1));[output[i],output[j]]=[output[j],output[i]]}return output}equals(rhs,loose=!1){return this.length===rhs.length&&(loose?this.every((x,i)=>x==rhs[i]):this.every((x,i)=>x===rhs[i]))}equalsWith(rhs,f){return this.length===rhs.length&&this.every((x,i)=>f(x,rhs[i],i))}clone(){return this.slice()}concat(...args){let output=new Yarra(this);for(var arg of args)arg instanceof Array?output.push(...arg):output.push(arg);return output}concatMutate(...args){for(var arg of args)arg instanceof Array?this.push(...arg):this.push(arg);return this}insertItem(x,i=0){return new Yarra(...this.slice(0,i),x,...this.slice(i))}insertList(list,i=0){return new Yarra(...this.slice(0,i),...list,...this.slice(i))}insertItemMutate(x,i=0){return this.splice(i,0,x),this}insertListMutate(list,i=0){return this.splice(i,0,...list),this}toArray(){return[...this]}}exports.Yarra=Yarra,Yarra.prototype.toGenerator=function*(){for(var x of this)yield x},Yarra.prototype.toCycleGenerator=function*(){for(;;)for(var x of this)yield x},Object.defineProperty(Yarra.prototype,"toGenerator",{enumerable:!1}),Object.defineProperty(Yarra.prototype,"toCycleGenerator",{enumerable:!1});const Y=(...args)=>new Yarra(...args);exports.Y=Y;