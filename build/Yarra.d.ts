declare class Yarra extends Array {
    static toIndices(input: any, shape: any): Yarra;
    static generateTemplate(input: any): Yarra;
    static allocate(...n: any[]): Yarra;
    static entries(x: any): Yarra;
    static range({ start, end, step, inclusive, }: {
        start?: number;
        end: number;
        step?: number;
        inclusive?: boolean;
    }): Yarra;
    static rangeMap({ start, end, step, inclusive, f, }: {
        start?: number;
        end: any;
        step?: number;
        inclusive?: boolean;
        f?: (x: any) => any;
    }): Yarra;
    static linSpace(start?: number, end?: number, n?: number): Yarra;
    static linSpaceMap(start: number, end: number, n: number, f: any): Yarra;
    constructor(...args: any[]);
    get head(): any;
    get last(): any;
    get full(): Yarra;
    get size(): number;
    get dimensions(): Yarra;
    written(oxfordComma?: boolean): any;
    initial(n?: number): any[];
    tail(n?: number): any[];
    compact(): any[];
    unique(loose?: boolean): any[];
    uniqueWith(f: any): any[];
    isUnique(loose?: boolean): boolean;
    isUniqueWith(f: any): boolean;
    count(f?: BooleanConstructor): any;
    occurrences(f?: (a: any) => any): {};
    sample(): any;
    chunk(n: any): any;
    uncover(n?: number): (this extends readonly (infer InnerArr)[] ? FlatArray<InnerArr, 0 | 2 | 1 | -1 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20> : this)[];
    cover(n?: number): any;
    elementWise(arr: any, f: any, singleDimension?: boolean): Yarra;
    add(arr: any): Yarra;
    mult(arr: any): Yarra;
    matrixMult(arr: any): Yarra;
    transpose(): any;
    transposeMutate(): any;
    sum(): any;
    product(): any;
    max(): number;
    min(): number;
    average(): number;
    none(f: any): boolean;
    mutate(newValue: any): any;
    get(...indices: any[]): this;
    set(...indices: any[]): (x: any) => this;
    getFrom(template: any): Yarra;
    setAllFrom(template: any, value: any): this;
    setFrom(template: any, values: any): this;
    at(...indices: any[]): any[];
    pullAt(...indices: any[]): any;
    mapMutate(f: any, thisArg?: any): any;
    filterMutate(f: any, thisArg?: any): any;
    rejectMutate(f: any, thisArg?: any): any;
    reject(f: any, thisArg?: any): any[];
    rejectFull(f: any, thisArg?: any): any[];
    filterFull(f: any, thisArg?: any): any[];
    split(f: any): Yarra;
    splitFull(f: any): Yarra;
    splitAt(...indices: any[]): any;
    findFull(f: any): any[];
    findLast(f: any): any;
    findLastIndex(f: any): number;
    findLastFull(f: any): any[];
    findAllIndex(f: any): any[];
    allIndexOf(v: any, loose?: boolean): any[];
    flattenDeep(): (this extends readonly (infer InnerArr)[] ? FlatArray<InnerArr, 0 | 2 | 1 | -1 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20> : this)[];
    shuffle(): Yarra;
    equals(rhs: any, loose?: boolean): boolean;
    equalsWith(rhs: any, f: any): boolean;
    clone(): Yarra;
    concat(...args: any[]): Yarra;
    concatMutate(...args: any[]): this;
    insertItem(x: any, i?: number): Yarra;
    insertList(list: any, i?: number): Yarra;
    insertItemMutate(x: any, i?: number): this;
    insertListMutate(list: any, i?: number): this;
    toArray(): this[number][];
    toGenerator: () => Generator<any, void, unknown>;
    toCycleGenerator: () => Generator<any, never, unknown>;
}
declare const Y: (...args: any[]) => Yarra;
declare let test: Yarra;
